<html>
<head>
  <title>Selenium Grid Overview</title>
  <link href="resources/Selenium Grid.css" rel="stylesheet" type="text/css" media="all">
</head>
<body>
  <h1>Selenium Grid Overview</h1>


  <h2>What is Selenium Grid?</h2>
    <p>
      Selenium Grid is a tool that dramatically speeds up web testing by leveraging your existing
      computing infrastructure. It allows you to easily run multiple tests in parallel, on multiple
      machines, in an heterogeneous enviroment.
    </p><p>
      Based on the excellent <a href="http://www.openqa.org/selenium/">Selenium</a>
      web testing tool, Selenium Grid allows you to run multiple instances of Selenium Remote Control in parallel.
      Even better, it makes all these Selenium Remote Controls appear as a single one, so your tests
      do not have to worry about the actual infrastructure.
      Selenium Grid cuts down on the time required to run a Selenium test suite to a fraction of the time that a
      single instance of Selenium instance would take to run.
    </p>
    <p>Last but not least, Selenium Grid is easy to use and simple to install.</p>

  <h2>How does it work?</h2>

    <p>
      To understand Selenium Grid you first need to understand how the standard
      <a href="http://www.openqa.org/selenium/">Selenium</a> web testing tool works.
    </p>

    <h3>Traditional Selenium Setup</h3>
      <p>
        Fundamentally, Selenium is a tool that let you programmatically launch a browser,
        drive the browser (open a url, enter some data, click on a link) and check the
        browser state (a section is visible, specific text is present, a widget is disabled).
        It is the tool of choice for automating web testing.
      </p><p>
        You drive the key piece in charge of controlling the browser, the Selenium
        Remote Control, by sending HTTP requests following a specific
        protocol (called Selenese). Therefore, basically all that a Selenium test does, is
        to target a specific Selenium Remote Control and to send it HTTP requests
        (through a higher level client API).
      </p>
      <p><img src="resources/Traditional Selenium Setup.png" alt=""></p>
      <p>
        This setup works great for a few tests, but as your test suite starts getting bigger,
        its limitations become clearer:
      </p>
  <ul>
    <li>
      The Selenium remote control is quite slow at driving the browser.
      Therefore, unless your application or your network is especially slow,
      the remote control/browser pair will end up being the bottleneck of your test suite.
    </li><li>
      You can only run a limited number of concurrent tests on the same remote
      control before seriously impacting its stability. Pratically speaking,
      launching more than 6 browsers on the same Selenium Remote Control is not
      advisable. The limitations are even more drastic for Internet Explorer.
    </li><li>
      Your tests can target multiple Selenium Remote Controls to work around the
      limitation on the number of parallel tests that you can run on a
      single remote control. Nevertheless that does not scale very well.
      It can easily be done at the continuous integration build level
      (one for Internet Explorer, one for Firefox, one for Safari).
      However, allocating a Selenium Remote Control to a specific test quickly becomes a
      nightmare if you want to run your selenium tests in a highly parallelized fashion.
      Your tests also become way too aware of the Selenium Remote Control
      infrastructure, which makes it difficult to evolve your infrastructure transparently.
    </li>
  </ul>
      <p>
          Due to all these limitations, Selenium tests typically run in sequence or are only
          mildly parallelized. That makes for test suites that take from half an hour to
          multiple hours to run. Not ideal, especially if you strive for Agile processes emphasizing
          a quick feedback loop.
      </p>

    <h3>Selenium Grid Setup</h3>
      <p>
        Selenium Grid builds on the traditional Selenium setup, taking advantage
        of the following properties:
      </p>
      <ul>
        <li>
          The Selenium test, the application under test, and the remote control/browser pair
          do not have to be co-located. They communicate through HTTP, so they can all
          live on different machines.
        </li><li>
          The Selenium tests and the web application under test are obviously specific to
          a particular project. Nevertheless, neither the Selenium remote control nor the
          browser is tied to a specific application. As a matter of fact, they provide a
          capacity that can easily be shared by multiple applications and multiple projects.
        </li>
      </ul>
      <p>
        Consequently, if only we could build a distributed grid of Selenium Remote Controls, we
        could easily share it accross builds, applications, projects &ndash; even potentially
        across organizations. Of course we would also need to address the
        scalability issues as described earlier when covering the traditional Selenium setup.
        This is why we need a component in charge of:
      </p>
      <ul>
          <li>Allocating a Selenium Remote Control to a specific test (transparently)</li>
          <li>Limiting the number of concurrent test runs on each Remote Control</li>
          <li>Shielding the tests from the actual grid infrastructure</li>
      </ul>
      <p>Selenium Grid calls this component the Selenium Hub.</p>
      <ul>
          <li>
            The Hub exposes an external interface that is exactly the same as the one of a traditional Remote Control.
            This means that a test suite can transparently target a regular Remote Control or a Selenium Hub with no
            code change. It just needs to target a different IP address. This is important as
            it shields the tests from the grid infractructure (which you can scale transparently). This
            also makes the developer's life easier. The <em>same</em> test can be run locally on a developer
            machine, or run on a heavy duty distributed grid as part of a build -- without ever changing a
            line of code.
          </li><li>
            The Hub allocates Selenium Remote Controls to each test. The Hub is also in charge of routing
            the Selenese requests from the tests to the appropriate Remote Control as well as keeping track of
            testing sessions.
          </li><li>
            When a new test starts, the Hub puts its first request on hold if there is no available Remote Control
            in the grid providing the appropriate capabilities. As soon as a suitable Remote Control becomes
            available, the Hub will serve the request. For the whole time, the tests do not have to be aware of
            what is happening within the grid; it is just waiting for an HTTP response to come back.
          </li>
      </ul>
      <p><img src="resources/Selenium Grid Setup.png" alt=""></p>
      <p>
        Of course to really take advantage of the Selenium Grid, you need to run your tests in parallel.
        If you are writing your Selenium tests in Java, you can leverage
        <a href="http://testng.org/doc/documentation-main.html#parallel-running">TestNG parallel runs</a>
        or <a href="https://parallel-junit.dev.java.net/">Parallel JUnit</a>. If you prefer to write
        your Selenium tests in Ruby, you might want to look into
        <a href="http://deep-test.rubyforge.org/">DeepTest</a> or spawn multiple processes. Chances are
        that your favorite programming language and development platform already have a solution.
      </p>

    <h2>Requesting a Specific Environment</h2>
      <p>
        A traditional Selenium test requests a specific browser at the beginning of every
        Selenium session. It requests it in the form of a pre-defined string such as
        <code>*firefox</code> or <code>*iexplore</code>. Nevertheless a test cannot
        request more fine grained capabilities such as <q>Firefox on Linux</q> or
        <q>IE 6.0 on Windows XP SP2</q>. The underlying assumption is that you are
        targetting a single Remote Control, so you should be aware if it runs on Windows
        XP or not.
      </p><p>
        If you want, you can operate a Selenium Grid in the exact same way. It might very well
        be all that you need. However the more heterogeous your grid becomes, the more you will
        want to make sure that a specific build runs on <q>Firefox on Windows</q> and only on
        <q>Firefox on Windows</q>. This makes troubleshooting test failures considerably easier. It
        might also be that you have a handful of tests that are specifically targeting this
        nasty bug for this particular browser on this particular platform.
      </p><p>
        Either way, you can make a Selenium Grid aware of the environments you care
        about. The Selenium Hub will then ensure that a test runs only on the Selenium Remote
        Controls providing the requested environment.
      </p>
      <p><img src="resources/Requesting a Specific Environments.png" alt=""></p>
      <p>
          The way it works is that Selenium Grid instruments the traditional Selenium
          Remote Controls so that they register themselves to the Hub when they start.
          When they do so they can also describe which environment they are providing, suppose
          <q>Firefox on Windows</q>.
      </p><p>
        At this point, if you want to target a test to a specific environment all, you have to
        do is to substitute the traditional browser string (say <code>*firefox</code>) with
        the name of the environment (say <code>Firefox on Windows</code>). If you write your
        test in Java change:
      </p><p>
        <code>new DefaultSelenium("localhost", 4444, <strong>'*chrome'</strong>, 'http://amazon.com');</code>
      <p>into:</p><p>
        <code>new DefaultSelenium("localhost", 4444, <strong>'Firefox on Windows'</strong>, 'http://amazon.com');</code>
      </p><p>
        That will do the trick.
      </p><p>
        It is important to note that the names of the environments are completely arbitrary. <em>You</em>
        are in control and can choose the ones that make sense for you. You are also not restricted to the
        browser / platform paradigm. You can define environments such as "IE 7 on Chinese locale" or
        "Firefox on Quadriprocessor" if that makes sense in your testing environment.
      </p><p>
        To define you own environments, edit the <code>grid_configuration.yml</code> file at the root
        of the Selenium Grid binary distribution.
      </p>


  <h3>One Remote Control = One browser = One Environment</h3>
    <p>
      The rationale is:
    </p>
    <ul>
      <li>This simplifies dramatically the remote control reservation/stickiness process
      <li>Easy to get something out the door quickly if we rely on this assumption on the
      short run
      <li>More than one IE instance for the same remote control does not work
      <li>Remote control is not very stable and need to be restarted quite often.
      The restart has less impact if only one browser is running at a time.
      <li>You can still scale by running multiple remote control on the same machine
      <li>This way each remote control can offer different environment capabilities on the
      same box. e.g "IE 7 on Windows" and "Firefox on Windows".
   </ul>

  <h2>You are the one in control</h2>

    <h3>The same test can run locally on a traditional remote control or remotely on the Selenium grid</h3>
      <ul>
        <li>
          The selenium test can run the same locally with a "classic" selenium setup or talking to the
   selenium grid => Tests are written as usual using your favorite selenium client driver
   (ruby, python, java, ...). This makes it easy to troubleshoot failing tests.
        </li><li>
           The selenium test itself is in charge on test isolation : reusing the same browser across test,
   rolling back database to a known state, etc. This is because the person writing the test
   is the only person who knows what makes sense for a specific web application and which
   tradeoff he is willing to take between test isis the only one
   aware
        </li>
      </ul>

  <h2>Lessons learned</h2>

    <ul>
      <li>Remote Control are not very robust, the need to be restarted regularly</li>
      <li>Running more than one IE on a remote control is not a good idea</li>
      <li>
        Two _major_ factors for the performance of your selenium test suite are:
        <ol>
          <li>Performance of the web server under test</li>
          <li>Performance of the network between the remote control and the web site under test</li>
        </ol>
      </li>
    </ul>
    
</body>
</html>     
